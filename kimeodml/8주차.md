[1. 콜백](#콜백)<br />
[2. 프라미스](#프라미스)<br />
[3. 프라미스 체이닝](#프라미스-체이닝)<br />
[4. 프라미스와 에러 핸들링](#프라미스와-에러-핸들링)<br />
[5. 프라미스 API](#프라미스-api)<br />
[6. 프라미스화](#프라미스화)<br />
[7. 마이크로태스크](#마이크로태스크)<br />
[8. async와 await](#async와-await)<br />

---
### 콜백
- *비동기* 동작을 스케줄링 할 수 있음 > `콜백`
	```
	function loadScript(src, callback) {
	  let script = document.createElement('script');
	  script.src = src;
	  script.onload = () => callback(script);
	  document.head.append(script);
	}
	
	loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script => {
	  alert(`${script.src}가 로드되었습니다.`);
	  alert( _ ); // 스크립트에 정의된 함수
	});
	```
	- 두 번째 인수로 전달된 함수(대개 익명 함수)는 원하는 동작이 완료되었을 때 실행됨
	- '콜백 기반' 비동기 프로그래밍 - 무언가를 비동기적으로 수행하는 함수는 함수 내 동작이 모두 처리된 후 실행되어야 하는 함수가 들어갈 `콜백`을 인수로 반드시 제공
		- `loadScript`의 인수로 콜백을 제공

<br />

- 두 개의 스크립트를 순차적으로 불러오고 싶을 때 > 콜백 중첩
	```
	loadScript('/my/script.js', function(script) {
	  alert(`${script.src}을 로딩했습니다. 이젠, 다음 스크립트를 로딩합시다.`);
	
	  loadScript('/my/script2.js', function(script) {
	    alert(`두 번째 스크립트를 성공적으로 로딩했습니다.`);
	  });
	});
	```

<br />

- 콜백에러 에러 처리 방법
	```
	function loadScript(src, callback) {
	  let script = document.createElement('script');
	  script.src = src;
	
	  script.onload = () => callback(null, script);
	  // 직접 에러 던지기
	  script.onerror = () => callback(new Error(`${src}를 불러오는 도중에 에러가 발생했습니다.`));
	
	  document.head.append(script);
	}
	
	loadScript('/my/script.js', function(error, script) {
	// 오류 우선 콜백(error-first callback)
	  if (error) {
	    // 에러 처리
	  } else {
	    // 스크립트 로딩이 성공적으로 끝남
	  }
	});
	```
	1. `callback`의 첫 번째 인수는 에러를 위해 남겨둠. 에러가 발생하면 이 인수를 이용해 `callback(err)`이 호출
	2. 두 번째 인수(필요하면 인수를 더 추가할 수 있음)는 에러가 발생하지 않았을 때를 위해 남겨둠. 원하는 동작이 성공한 경우엔 `callback(null, result1, result2...)`이 호출됨

<br />

- `콜백`에서 비동기 동작이 많아질 경우 > 콜백 지옥 / 멸망의 피라미드 발생
	```
	loadScript('1.js', function(error, script) {
	
	  if (error) {
	    handleError(error);
	  } else {
	    // ...
	    loadScript('2.js', function(error, script) {
	      if (error) {
	        handleError(error);
	      } else {
	        // ...
	        loadScript('3.js', function(error, script) {
	          if (error) {
	            handleError(error);
	          } else {
	            // 모든 스크립트가 로딩된 후, 실행 흐름이 이어집니다. (*)
	          }
	        });
	
	      }
	    })
	  }
	});
	```
	- 독립적인 함수를 만들어서 해결하는 방법도 존재 > 재사용 가능한 함수로 만들지 못함 > '프라미스' 사용

### 프라미스
- `promise` 의 문법 구조
	```
	let promise = new Promise(function(resolve, reject) {
	  // executor (제작 코드, '가수')
	});
	```
	- `new Promise`에 전달되는 함수는 *executor(실행자, 실행 함수)* 라고 부름
	- executor는 `new Promise`가 만들어질 때 자동으로 실행되는데, 결과를 최종적으로 만들어내는 제작 코드를 포함함
		- `resolve(value)` - 일이 성공적으로 끝난 경우 그 결과를 나타내는 `value`와 함께 호출
		- `reject(error)` - 에러 발생 시 에러 객체를 나타내는 `error`와 함께 호출
-  `new Promise` 생성자가 반환하는 `promise` 객체는 아래와 같은 내부 프로퍼티를 가짐
	- `state` - 처음엔 `'pending'`(보류)이었다 `resolve`가 호출되면 `'fulfilled'`, `reject`가 호출되면 `'rejected'`로 변함
	- `result` - 처음엔 `undefined`이었다 `resolve(value)`가 호출되면 `value`로, `reject(error)`가 호출되면 `error`로 변함
	![[Pasted image 20240826172506.png|400]]

<br />

- 프라미스 객체는 executor와 결과나 에러를 받을 소비 함수를 이어주는 역할
	- 소비함수는 `.then`, `.catch`, `.finally` 메서드를 사용해 등록

**then**
- `.then`의 문법 구조
	```
	promise.then(
	  function(result) { /* 결과(result)를 다룹니다 */ },
	  function(error) { /* 에러(error)를 다룹니다 */ }
	);
	```
	- `.then`의 첫 번째 인수는 프라미스가 이행되었을 때 실행되는 함수이고, 실행결과를 다룸
	- 두 번째 인수는 프라미스가 거부되었을 때 실행되는 함수이고, 에러를 다룸

<br />

- 성공적으로 이행된 프라미스 코드 예시
	```
	let promise = new Promise(function(resolve, reject) {
	  setTimeout(() => resolve("완료!"), 1000);
	});
	
	// resolve 함수는 .then의 첫 번째 함수(인수)를 실행합니다.
	promise.then(
	  result => alert(result), // 1초 후 "완료!"를 출력
	  error => alert(error) // 실행되지 않음
	);
	
	// 성공적인 결과물만 다루고 싶을 경우
	let promise = new Promise(resolve => {
	  setTimeout(() => resolve("완료!"), 1000);
	});
	
	promise.then(alert); // 1초 뒤 "완료!" 출력
	```

**catch**
- 에러가 발생한 경우만 다루고 싶을 경우
	- `.then(null, errorHandlingFunction)`
	- `.catch(errorHandlingFunction)`
	```
	let promise = new Promise((resolve, reject) => {
	  setTimeout(() => reject(new Error("에러 발생!")), 1000);
	});
	
	// .catch(f)는 promise.then(null, f)과 동일하게 작동합니다
	promise.catch(alert); // 1초 뒤 "Error: 에러 발생!" 출력
	```

**finally**
- 결과가 어떻든 마무리가 필요하면 `finally`를 사용
	- `finally(f)`
	- `.then(f,f)`
	```
	new Promise((resolve, reject) => {
	  /* 시간이 걸리는 어떤 일을 수행하고, 그 후 resolve, reject를 호출함 */
	})
	  // 성공·실패 여부와 상관없이 프라미스가 처리되면 실행됨
	  .finally(() => 로딩 인디케이터 중지)
	  .then(result => result와 err 보여줌 => error 보여줌)
	```

<br />

- finally와 `.then(f,f)`의 차이점
	1. `finally` 핸들러엔 인수가 없음. `finally`에선 프라미스가 이행되었는지, 거부되었는지 알 수 없음. `finally`에선 절차를 마무리하는 '보편적' 동작을 수행하기 때문에 성공•실패 여부를 몰라도 됨
	2. `finally` 핸들러는 자동으로 다음 핸들러에 결과와 에러를 전달
		```
		// 프라미스에서 에러가 발생하고 이 에러가 finally를 거쳐 catch까지 전달됨
		new Promise((resolve, reject) => {
		  setTimeout(() => resolve("결과"), 2000)
		})
		  .finally(() => alert("프라미스가 준비되었습니다."))
		  .then(result => alert(result)); // <-- .then에서 result를 다룰 수 있음
		```
		- `finally`는 프라미스 결과를 처리하기 위해 만들어진 게 아님. 프라미스 결과는 `finally`를 통해 전달됨
	3. `.finally(f)`는 함수 `f`를 중복해서 쓸 필요가 없기 때문에 `.then(f,f)`보다 문법 측면에서 편리함

<br />

- 프라미스를 활용한 `loadScript` 코드
	```
	function loadScript(src) {
	  return new Promise(function(resolve, reject) {
	    let script = document.createElement('script');
	    script.src = src;
	
	    script.onload = () => resolve(script);
	    script.onerror = () => reject(new Error(`${src}를 불러오는 도중에 에러가 발생함`));
	
	    document.head.append(script);
	  });
	}
	
	let promise = loadScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");
	
	promise.then(
	  script => alert(`${script.src}을 불러왔습니다!`),
	  error => alert(`Error: ${error.message}`)
	);
	
	promise.then(script => alert('또다른 핸들러...'));

	```

### 프라미스 체이닝
- 순차적으로 처리해야 하는 비동기 작업이 여러 개 있을 경우 > 프라미스 체이닝
	```
	new Promise(function(resolve, reject) {
	  setTimeout(() => resolve(1), 1000); // (*)
	}).then(function(result) { // (**)
	  alert(result); // 1
	  return result * 2;
	}).then(function(result) { // (***)
	  alert(result); // 2
	  return result * 2;
	}).then(function(result) {
	  alert(result); // 4
	  return result * 2;
	});
	```
	- `result`가 `.then` 핸들러의 체인(사슬)을 통해 전달됨
		1. 1초 후 최초의 프라미스가 이행됨 - `(*)`
		2. 이후 첫번째 `.then` 핸들러가 호출 - `(**)`
		3. 2에서 반환한 값음 다음 `.then` 핸들러에 전달 - `(***)`
		4. 위와 같은 과정 반복

<br />

- **프라미스 하나에 `.then`을 여러개 추가한 것은 체이닝이 아님**
	```
	let promise = new Promise(function(resolve, reject) {
	  setTimeout(() => resolve(1), 1000);
	});
	
	promise.then(function(result) {
	  alert(result); // 1
	  return result * 2;
	});
	
	promise.then(function(result) {
	  alert(result); // 1
	  return result * 2;
	});
	
	promise.then(function(result) {
	  alert(result); // 1
	  return result * 2;
	});
	```
	- `result`를 순차적으로 전달하지 않고 독립적으로 처리한 것임
	![[Pasted image 20240827142426.png|400]]
	- 동일한 프라미스에 등록된 `.then` 모두 동일한 결과(`result`)를 받음 > 전부 `1` 출력
	- 이런 식으로 한 프라미스에 여러 개의 핸들러를 등록해서 사용하는 경우는 없음 > 체이닝으로 써야 함

<br />

- `.then(handler)`에 사용된 핸들러가 프라미스를 생성하거나 반환하는 경우도 있음
- 핸들러는 프라미스가 처리될 때까지 기다리다가 처리가 완료되면 그 결과를 받음
	```
	new Promise(function(resolve, reject) {
	  setTimeout(() => resolve(1), 1000);
	}).then(function(result) {
	  alert(result); // 1
	  return new Promise((resolve, reject) => { // (*)
	    setTimeout(() => resolve(result * 2), 1000);
	  });
	}).then(function(result) { // (**)
	  alert(result); // 2
	  return new Promise((resolve, reject) => {
	    setTimeout(() => resolve(result * 2), 1000);
	  });
	}).then(function(result) {
	  alert(result); // 4
	});
	```
	- 첫 번째 `.then`은 `1`을 출력하고 `new Promise(...)`를 반환 - `(*)`
	- 1초 후 이 프라미스가 이행되고 그 결과는 두번째 `.then`으로 전달. 두 번째 핸들러는 `2`를 출력 - `(**)`
	- 동일한 과정 반복
	=> 동일한 결과물이 출력되지만 setTimeout에 의해 1초의 딜레이가 생김

<br />

- `.then`을 사용해 `loadScript` 개선
	```
	loadScript("/article/promise-chaining/one.js")
	  .then(script => loadScript("/article/promise-chaining/two.js"))
	  .then(script => loadScript("/article/promise-chaining/three.js"))
	  .then(script => {
	    // 스크립트를 정상적으로 불러왔기 때문에 스크립트 내의 함수를 호출할 수 있습니다.
	    one();
	    two();
	    three();
	  });
	```

### 프라미스와 에러 핸들링
- 프라미스가 거부되면 제어 흐르미이 제일 가까운 rejection 핸들러로 넘어감 > `.catch`에서 에러 처리
	```
	fetch('/article/promise-chaining/user.json')
	  .then(response => response.json())
	  .then(user => fetch(`https://api.github.com/users/${user.name}`))
	  .then(response => response.json())
	  .then(githubUser => new Promise((resolve, reject) => {
	    let img = document.createElement('img');
	    img.src = githubUser.avatar_url;
	    img.className = "promise-avatar-example";
	    document.body.append(img);
	
	    setTimeout(() => {
	      img.remove();
	      resolve(githubUser);
	    }, 3000);
	  }))
	  .catch(error => alert(error.message));
	```

<br />

- `throw` 핸들러를 통해 에러를 던질 수 있음
	```
	new Promise((resolve, reject) => {
	  resolve("OK");
	}).then((result) => {
	  throw new Error("에러 발생!"); // 프라미스가 거부됨
	}).catch(alert); // Error: 에러 발생!
	```

<br />

- 프라미스도 유사하게 `try..catch` 처럼 처리할 수 없는 에러라 판단되면 에러를 다시 던질 수 있음
	```
	// 실행 순서: catch -> catch
	new Promise((resolve, reject) => {
	  throw new Error("에러 발생!");
	}).catch(function(error) { // (*)
	  if (error instanceof URIError) {
	    // 에러 처리
	  } else {
	    alert("처리할 수 없는 에러");
	    throw error; // 에러 다시 던지기
	  }
	}).then(function() {
	  /* 여기는 실행되지 않습니다. */
	}).catch(error => { // (**)
	  alert(`알 수 없는 에러가 발생함: ${error}`);
	  // 반환값이 없음 => 실행이 계속됨
	});
	```
	- `(*)`에서 에러를 처리하지 못 했기 때문에 에러를 다시 던짐

### 프라미스 API
**Pormise.all**
- 모든 프라미스가 이행될 때까지 기다렸다가 그 결괏값을 담을 배열을 반환
- **주어진 프라미스 중 하나라도 실패하면 `Promise.all`은 거부되고, 나머지 프라미스의 결과는 무시됨**
	```
	Promise.all([
	  new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
	  new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
	  new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
	]).then(alert); // 프라미스 전체가 처리되면 1, 2, 3이 반환됩니다. 각 프라미스는 배열을 구성하는 요소가 됩니다.
	```

**Promise.allSettled**
- 프라미스가 처리될 때까지 기다렸다가 그 결과를 담은 배열을 반환
	- 응답 성공 - `{status:'fulfilled', value:result}`
	- 응답 실패 - `{status:'rejected', reason:error}`
	```
	let urls = [
	  'https://api.github.com/users/iliakan',
	  'https://api.github.com/users/Violet-Bora-Lee',
	  'https://no-such-url'
	];
	
	Promise.allSettled(urls.map(url => fetch(url)))
	  .then(results => { // (*)
	    results.forEach((result, num) => {
	      if (result.status == "fulfilled") {
	        alert(`${urls[num]}: ${result.value.status}`);
	      }
	      if (result.status == "rejected") {
	        alert(`${urls[num]}: ${result.reason}`);
	      }
	    });
	  });
	
	// 응답 결과 (값 또는 에러의 결괏값을 받음)
	[
	  {status: 'fulfilled', value: ...응답...},
	  {status: 'fulfilled', value: ...응답...},
	  {status: 'rejected', reason: ...에러 객체...}
	]
	```

**Promise.race**
- 가장 먼저 처리된 프라미스의 결과 또는 에러를 담은 프라미스를 반환
	```
	Promise.race([
	  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
	  new Promise((resolve, reject) => setTimeout(() => reject(new Error("에러 발생!")), 2000)),
	  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
	]).then(alert); // 1
	```

**Promise.resolve**
- Promise.resolve - 주어진 값을 사용해 이행 상태의 프라미스를 만듦
- Promise.reject - 주어진 에러를 사용해 거부 상태의 프라미스를 만듦
- async/await이 대신하게 되었음

### 프라미스화
- 콜백을 받는 함수를 프라미스를 반환하는 함수로 바꾸는 것을 '프라미스화'라고 함
- 콜백보다 프라미스가 편리하기 때문에 콜백 기반 라이브러리를 프라미스를 반환하는 함수로 바꾸는 게 좋은 경우가 종종 있음
- `loadScript(src, callback)`를 프라미스화하기
	```
	// Before
	function loadScript(src, callback) {
	  let script = document.createElement('script');
	  script.src = src;
	
	  script.onload = () => callback(null, script);
	  script.onerror = () => callback(new Error(`${src}를 불러오는 도중에 에러가 발생함`));
	
	  document.head.append(script);
	}
	
	// 사용법:
	// loadScript('path/script.js', (err, script) => {...})
	
	// After
	let loadScriptPromise = function(src) {
	  return new Promise((resolve, reject) => {
	    loadScript(src, (err, script) => { // callback을 제외한 src 인수만 필요 + Promise를 반환
	      if (err) reject(err)
	      else resolve(script);
	    });
	  })
	}
	
	// 사용법:
	// loadScriptPromise('path/script.js').then(...)
	```
	- `loadScriptPromsie`는 기존 함수 `loadScirpt`에 모든 일을 위임함
	- `loadScript`의 콜백은 스크립트 로딩 상태에 따라 `이행(fulfilled)` 혹은 `거부(rejected)` 상태의 프라미스를 반환

### 마이크로태스크
- 프라미스 핸들러 `.then/catch/finally`는 항상 비동기적으로 실행
- 프라미스가 즉시 이행되더라도 `.then/catch/finally` *아래*에 있는 코드는 이 핸들러들이 실행되기 전에 실행됨
	```
	// '코드 종료!' -> '프라미스 성공!'
	let promise = Promise.resolve();
	
	promise.then(() => alert("프라미스 성공!"));
	alert("코드 종료"); // 얼럿 창이 가장 먼저 뜹니다.
	```

- 비동기 작업을 처리하려면 적절한 관리가 필요 > '마이크로태스크 큐'에서 관리
	- 마이크로태스크 큐는 먼저 들어온 작업을 먼저 실행함(FIFO)
	- 실행할 것이 아무것도 남지 않을 때만 마이크로태스크 큐에 있는 작업이 실행됨
- 어떤 프라미스가 준비되었을 때 이 프라미스의 `.then/catch/finally` 핸들러가 큐에 들어간다고 생각하시면 됨. 이때 핸들러는 여전히 실행되지 않음. 현재 코드에서 자유로운 상태가 되었을 때에세어ㅑ 자바스크립트 엔진은 큐에서 작업을 꺼내 실행함 < '코드 종로'가 먼저 출력되는 이유
	![[Pasted image 20240829131519.png|400]]

<br />

-  프라미스 핸들러는 항상 내부 큐를 통과함
- 여러 개의 `.then/catch/finally`를 사용해 만든 체인의 경우, 각 핸들러는 비동기적으로 실행됨. 큐에 들어간 핸들러 각각은 현재 코드가 완료되고, 큐에 적제된 이전 핸들러의 실행이 완료되었을 때 실행됨
- **'프라미스 성공!'을 먼저, '코드 종료'를 나중에 출력되게 하려면 어떻게 해야 하나?'** > `.then`을 사용해 큐에 넣기
	```
	Promise.resolve()
	  .then(() => alert("프라미스 성공!"))
	  .then(() => alert("코드 종료"));
	```
	
### async와 await
- function 앞에 `async`를 붙이면 해당 함수는 항상 프라미스를 반환
- `await`은 프라미스가 처리될 때까지 기다림
- [프라미스 체이닝](https://ko.javascript.info/promise-chaining) 챕터의 `showAvatar()` 예시를 `async/await`로 작성
	1. `.then` 호출을 `await`으로 변경
	2. function 앞에 `async`를 붙여 `await`를 사용할 수 있도록 함
	```
	async function showAvatar() {
	  // JSON 읽기
	  let response = await fetch('/article/promise-chaining/user.json');
	  let user = await response.json();
	
	  // github 사용자 정보 읽기
	  let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
	  let githubUser = await githubResponse.json();
	
	  // 아바타 보여주기
	  let img = document.createElement('img');
	  img.src = githubUser.avatar_url;
	  img.className = "promise-avatar-example";
	  document.body.append(img);
	
	  // 3초 대기
	  await new Promise((resolve, reject) => setTimeout(resolve, 3000));
	  img.remove();
	  return githubUser;
	}
	
	showAvatar();
	```

<br />

- `try..catch`를 사용해 에러 핸들링
	```
	async function f() {
	  try {
	    let response = await fetch('http://유효하지-않은-주소');
	    let user = await response.json();
	  } catch(err) {
		// fetch와 response.json에서 발행한 에러 모두를 여기서 잡습니다.
	    alert(err); // TypeError: failed to fetch
	  }
	}
	
	f();
	```