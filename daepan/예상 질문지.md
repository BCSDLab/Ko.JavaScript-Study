# JavaScript 면접 질문 예상
## 자바스크립트 기본형 데이터 타입에는 어떤 것이 있을까요?
* number, string, boolean, null, undefined, Symbol, BigInt 가 있습니다.

## 참조형 데이터 타입에는 어떤 것이 있을까요?
object 타입에는 객체, 함수, 배열 등이 있습니다.

## 자바스크립트의 데이터 타입에는 기본형, 참조형 타입이 있습니다. 이 두 가지의 차이점은 무엇인가요?
* 기본형의 경우 Call Stack 에 값을 할당합니다. 그러나, 참조형의 경우 Memory Heap에 값을 할당하며 해당 Heap 주소값을 Call Stack 에 할당합니다.

## 기본형 타입은 immutability 한 성질을 가지고 있습니다. 이는 어떤 의미일까요?
* 불변성은 해당 식별자가 참조하는 값이 변하지 않는 다는 것입니다. 10, 20의 경우, 변수값 선언 시점에 메모리를 새로 생성하여 주소값을 받게 됩니다. 식별자 a 가 가리키고 있는 주소값은 이전에 10에서 20으로 변하게 됩니다. 즉, 식별자가 가리키는 주소값이 변하는 것이지 기본형 타입이 변하는 것은 아닙니다

## 얕은 복사와 깊은 복사는 어떤 점이 다른가요?
얕은 복사는 복사할 대상 객체의 주소값만 복사합니다. 그러나, 깊은 복사는 대상 객체 주소값이 참조하고 있는 Memory heap 에 있는 대상의 값들을 복사합니다. 때문에, 얕 은 복사가 참조하고 있는 값을 변화시키면 해당 주소값을 참조하고 있는 모든 값이 변 화합니다. 그러나, 깊은 복사는 아예 다른 주소값을 참조하고 있으므로 이전 참조값이 변화하지 않습니다.

## 실행 컨텍스트란 무엇인가요?
자바스크립트 엔진에 의해 만들어지고 사용하는 코드 정보를 담은 객체 집합입니다. 실행할 코드에 제공할 환경 정보를 모아놓은 객체입니다.

## 실행 컨텍스트를 생성하는 방법은 어떤 것이 있을까요?
전역 공간, eval() 함수, 함수 호출이 있습니다. 각 방법은 자신만의 실행 컨텍스트를 생성합니다

## 실행 컨텍스트에 수집되는 정보는 어떤 것이 있나요?
VariableEnvironment, LexicalEnvironment, thisBinding 이 수집됩니다.

## ES5, ES6 에서의 스코프 생성 규칙을 설명해주세요.
ES5 에서는 함수에 의해서만 스코프가 생성됩니다. 이 때문에 if, while() 문 블록 내에 서의 식별자를 블록 바깥에서 접근할 수 있습니다. 그러나 ES6 에서는 블록에 의해서 스코프가 생성됩니다. 즉, 내부에 선언된 변수를 참조할 수 없습니다.

## this 는 언제 결정되나요?
함수를 호출할 때 결정됩니다.
콜백 함수에서 this 는 어떻게 결정되나요? 제어권을 위임한 객체에 바인딩됩니다.

## arrow function 의 this 가 결정되는 방식을 설명해보세요.
function keyword 는 this 가 동적으로 결정되지만, arrow function 의 경우는 정적으로 결정됩니다. 호출되는 순간 자신을 감싼 scope 를 가리키게 되는데, method 로 호출되거나 등의 명시적인 바인딩 함수도 무시되며 오로지 scope 에 의해 결정됩니다.

## 명시적으로 this 를 바인딩 할 수 있는 메서드는 어떤것이 있나요?
call, apply, bind 가 있습니다.

## this 바인딩의 우선순위에 대해 설명해보세요.
1. new 를 사용하여 함수 생성자로서 호출할 때, 해당 객체로 바인딩 됩니다.
2. call, apply, bind 등의 명시적 바인딩을 사용했을 때 인자로 전달된 객체에 바인딩 됩니다.
3. 객체의 method 로 함수를 호출할 때, 해당 객체에 바인딩 됩니다.
4. 그 외의 경우, 일 경우로 초기화되며 아니라면 브라우저는 객체에 바인딩됩니다

## Closure가 뭔가요?
클로저는 함수와 그 함수가 선언될 당시의 어휘적 환경(Lexical Environment)의 상호 관계에 따른 현상입니다. 내부 함수가 외부 함수의 변수에 접근할 수 있는 이유는 이 상호관계 때문입니다.
어휘적 환경(Lexical Environment)은 실행 컨텍스트의 구성 요소 중 하나로, 변수의 유효 범위를 결정하고 스코프 체인을 가능하게 합니다. 어떤 컨텍스트 A에서 선언한 내부 함수 B가 실행될 때, B의 어휘적 환경은 A의 어휘적 환경을 참조합니다. 이를 통 해 B는 A의 변수를 참조할 수 있습니다.

## const 의 경우엔 hoisting 이 일어나지 않는데, 이 이유는 무엇일까요?
엄밀히 말하면, hoisting 은 일어나지만 TDZ 에 있기 때문에 사용할수는 없습니다.
실행 컨텍스트가 생성될 때, let, const 로 생성된 식별자는 선언부가 수집되지만 값이 할당되지 않습니다. 이에 반해, var 식별자는 undefined 값이 할당되므로 식별자 선언 이전에 값을 사용할 수 있습니다.

## 호이스팅은 어떤 것인가요?
실행 컨텍스트 생성 시 Lexical Scope 내의 선언이 끌어올려지는 것을 호이스팅이라고 합니다.

## 호이스팅이 발생하는 시점은 언제인가요?
실행 컨텍스트가 활성화 될 때, 호이스팅이 발생합니다.