# 클래스와 기본 문법

모던 자바스크립트에 도입된 `클래스(class` 라는 문법을 사용하면 객체 지향 프로그래밍에서 사용되는 다양한 기능을 자바스크립트에서도 사용할 수 있다.

## 기본 문법

```jsx
class User {

  constructor(name) {
    this.name = name;
  }

  sayHi() {
    alert(this.name);
  }

}

// 사용법
let user = new User("John");
user.sayHi();
```

클래스를 만들고, `new User("John")` 를 호출하면 내부에서 정의한 메서드가 들어있는 객체가 생성된다.

생성자 메서드 `constructor` 는 new에 의해 자동으로 호출되므로, 특별한 절차 없이 객체를 초기화 할 수 있다.

## 클래스란

자바스크립트에서 클래스는 함수의 한 종류이다.

```jsx
class User {
  constructor(name) { this.name = name; }
  sayHi() { alert(this.name); }
}

// User가 함수라는 증거
alert(typeof User); // function
```

`class User { ... }` 문법 구조가 하는 일은 다음과 같다.

1. `User` 라는 이름을 가진 함수를 만든다. 함수 본문은 생성자 메서드 `constructor` 에서 가져온다. 생성자 메서드가 없으면 본문이 비워진 채로 함수가 만들어진다.
2. `sayHi` 같은 클래스 내에서 정의한 메서드를 `User.prototype` 에 저장한다.

`new User` 를 호출해 객체를 만들고, 객체의 메서드를 호출하면 메서드를 prototype 프로퍼티를 통해 가져온다.

![](https://velog.velcdn.com/images/ehgns0305/post/40869737-c8b1-478e-ac3f-960e002c2162/image.png)

```jsx
// 생성자 메서드와 동일하다.
alert(User === User.prototype.consturctor); // true

alert(User.prototype.sayHi) // alert(this.name)

alert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi
```

## 클래스는 단순한 편의 문법이 아니다.

`class` 라는키워드 없이도 클래스 역할을 하는 함수를 선언할 수 있기 때문에(`function`, `prototype`) 클래스를 syntatic sugar라고 말하기도 한다.

1. class로 만든 함수엔 특수 내부 프로퍼티인 `[[IsClassConstructor]]: true` 가 붙는다.
2. 클래스에 정의된 메서드는 열거할 수 없다. 클래스의 `prototype` 프로퍼티에 enumerable 플래그가 true 이기 때문이다.
3. 클래스는 항상 엄격 모드로 실행된다.

## 클래스 표현식

함수처럼 클래스도 다른 표현식 내부에서 정의, 전달, 반환, 할당할 수 있다.

```jsx
let User = class {
	sayHi() {
		alert("안녕하세요");
	}
}
```

기명 함수 표현식과 유사하게 클래스 표현식에도 이름을 붙일 수 있다. 필요에 따라 클래스를 동적으로 생성하는 것도 가능하다.

```jsx
function makeClass(phrase) {
  // 클래스를 선언하고 이를 반환함
  return class {
    sayHi() {
      alert(phrase);
    };
  };
}

// 새로운 클래스를 만듦
let User = makeClass("안녕하세요.");

new User().sayHi(); // 안녕하세요.
```

## getter와 setter

리터럴을 사용해 만든 객체처럼 클래스도 getter나 setter, 계산된 프로퍼티를 지원한다.

```jsx
class User {

  constructor(name) {
    // setter를 활성화합니다.
    this.name = name;
  }

  get name() {
    return this._name;
  }

  set name(value) {
    if (value.length < 4) {
      alert("이름이 너무 짧습니다.");
      return;
    }
    this._name = value;
  }

}

let user = new User("보라");
alert(user.name); // 보라

user = new User(""); // 이름이 너무 짧습니다.
```

## 클래스 필드

클래스 필드라는 문법을 사용하면 어떤 종류의 프로퍼티도 클래스에 추가할 수 있다.

```jsx
class User {
  name = "보라";

  sayHi() {
    alert(`${this.name}님 안녕하세요!`);
  }
}

new User().sayHi(); // 보라님 안녕하세요!
```

클래스 필드의 특징 중 하나는 `User.prototype`이 아닌 개별 객체에만 클래스 필드가 설정된다는 점이다.

### 클래스 필드로 바인딩 된 메서드 만들기

함수 바인딩 챕터에서 살펴본 것처럼 자바스크립트에서 `this` 는 동적으로 결정된다.

객체 메서드를 여기저기 전달해 전혀 다른 컨텍스트에서 호출하게 되면 this는 메서드가 정의된 객체를 참도하지 않는다.

```jsx
class Button {
  constructor(value) {
    this.value = value;
  }

  click() {
    alert(this.value);
  }
  // 각 Button 마다 독립적인 함수를 만듦
  click = () => {
    alert(this.value);
  }
}

let button = new Button("안녕하세요.");

setTimeout(button.click, 1000); // undefined
```

1. `setTimeout(() => button.click(), 1000)` 같이 래퍼 함수를 전달하기
2. 생성자 안 등에서 메서드를 객체에 바인딩하기

# 클래스 상속

## extends

```jsx
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  run(speed) {
    this.speed = speed;
    alert(`${this.name} 은/는 속도 ${this.speed}로 달립니다.`);
  }
  stop() {
    this.speed = 0;
    alert(`${this.name} 이/가 멈췄습니다.`);
  }
}

let animal = new Animal("동물");

class Rabbit extends Animal {
  hide() {
    alert(`${this.name} 이/가 숨었습니다!`);
  }
}

let rabbit = new Rabbit("흰 토끼");

rabbit.run(5); // 흰 토끼 은/는 속도 5로 달립니다.
rabbit.hide(); // 흰 토끼 이/가 숨었습니다!
```

토끼는 동물이므로 `Rabbit` 은 동물 관련 메서드가 담긴 `Animal` 을 확장해서 만들어야 한다. 동물이 할 수 있는 일반적인 동작을 수행할 수 있다.

![](https://velog.velcdn.com/images/ehgns0305/post/c2ca3a19-42e4-4c4d-a7ce-b969e45e4aa0/image.png)
엔진은 다음 절차를 따라 메서드 `rabbit.run`의 존재를 확인한다.

1. 객체 `rabbit`에 `run`이 있나 확인한다.
2. `rabbit`의 프로토타입인 `Rabbit.prototype`에 메서드가 있나 확인합니다. `hide`는 있는데 `run`은 없다.
3. `extends`를 통해 관계가 만들어진 `Rabbit.prototype`의 프로토타입, `Animal.prototype`에 메서드가 있나 확인한다.

## 메서드 오버라이딩

Child에 정의된 메서드에서 `super.method()` 를 사용하여 `Parent` 에 정의된 메서드를 사용할 수 있다.

```jsx
class Animal {

  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  run(speed) {
    this.speed = speed;
    alert(`${this.name}가 속도 ${this.speed}로 달립니다.`);
  }

  stop() {
    this.speed = 0;
    alert(`${this.name}가 멈췄습니다.`);
  }

}

class Rabbit extends Animal {
  hide() {
    alert(`${this.name}가 숨었습니다!`);
  }

  stop() {
    super.stop(); // 부모 클래스의 stop을 호출해 멈추고,
    this.hide(); // 숨습니다.
  }
}

let rabbit = new Rabbit("흰 토끼");

rabbit.run(5); // 흰 토끼가 속도 5로 달립니다.
rabbit.stop(); // 흰 토끼가 멈췄습니다. 흰 토끼가 숨었습니다!
```

`Rabbit` 은 이제 실행 중간에 부모 클래스에 정의된 메서드 `super.stop()` 을 호출하는 `stop` 을 가지게 된다.

## 생성자 오버라이딩

상속 클래스의 생성자엔 반드시 `super()` 를 호출해야 한다. `super` 는 `this` 를 사용하기 전에 반드시 호출해야 한다.

왜 super를 호출해야 할까?

- 상속 클래스의 생성자 함수와 그렇지 않은 생성자 함수를 구분한다. 상속 클래스의 생성자 함수엔 특수 내부 프로퍼티인 `[[ConstructorKind]]: "derived"` 가 이름표처럼 붙는다.
- 일반 클래스가 `new`와 함께 실행되면, 빈 객체가 만들어지고 `this`에 이 객체를 할당한다.
- 반면, 상속 클래스의 생성자 함수가 실행되면, 일반 클래스에서 일어난 일이 일어나지 않는다. 상속 클래스의 생성자 함수는 빈 객체를 만들고 `this`에 이 객체를 할당하는 일을 부모 클래스의 생성자가 처리해주길 기대한다.

```jsx
class Animal {

  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  // ...
}

class Rabbit extends Animal {

  constructor(name, earLength) {
    super(name);
    this.earLength = earLength;
  }

  // ...
}

// 이제 에러 없이 동작합니다.
let rabbit = new Rabbit("흰 토끼", 10);
alert(rabbit.name); // 흰 토끼
alert(rabbit.earLength); // 10
```

## 필드 오버라이딩

# 정적 메서드와 정적 프로퍼티

`prototype` 이 아닌 클래스 함수 자체에 메서드를 설정할 수 있다. 이런 메서드를 정적(static) 메서드라고 부른다.

```jsx
class User {
  static staticMethod() {
    alert(this === User);
  }
}

User.staticMethod(); // true
```

`User.staticMathod`가 호출될 때 `this` 의 값은 클래스 생성자인 `User` 자체가 된다.

정적 메서드는 어떤 특정한 객체가 아닌 클래스에 속한 함수를 구현하고자 할 때 주로 사용된다.

예시

```jsx
class Article {
  constructor(title, date) {
    this.title = title;
    this.date = date;
  }

  static compare(articleA, articleB) {
    return articleA.date - articleB.date;
  }
  
    static createTodays() {
    // this는 Article입니다.
    return new this("Today's digest", new Date());
  }
}

// 사용법
let articles = [
  new Article("HTML", new Date(2019, 1, 1)),
  new Article("CSS", new Date(2019, 0, 1)),
  new Article("JavaScript", new Date(2019, 11, 1))
];

articles.sort(Article.compare);

alert( articles[0].title ); // CSS

let article = Article.createTodays();

alert( article.title ); // Today's digest
```

### 정적 프로퍼티

정적 프로퍼티는 일반 클래스 프로퍼티와 유사하게 생겼는데 앞에 `static` 이 붙는다는 점만 다르다.

```jsx
class Article {
  static publisher = "Ilya Kantor";
}

alert( Article.publisher ); // Ilya Kantor
```

### 정적 프로퍼티와 메서드 상속

정적 프로퍼티와 메서드는 상속된다.

```jsx
// 예시
class Animal {
  static planet = "지구";

  constructor(name, speed) {
    this.speed = speed;
    this.name = name;
  }

  run(speed = 0) {
    this.speed += speed;
    alert(`${this.name}가 속도 ${this.speed}로 달립니다.`);
  }

  static compare(animalA, animalB) {
    return animalA.speed - animalB.speed;
  }

}

// Animal을 상속받음
class Rabbit extends Animal {
  hide() {
    alert(`${this.name}가 숨었습니다!`);
  }
}

let rabbits = [
  new Rabbit("흰 토끼", 10),
  new Rabbit("검은 토끼", 5)
];

rabbits.sort(Rabbit.compare);

rabbits[0].run(); // 검은 토끼가 속도 5로 달립니다.

alert(Rabbit.planet); // 지구
```

# private, protected 프로퍼티와 메서드

객체 지향 프로그래밍에서 가장 중요한 원리 중 하나는 `내부 인터페이스와 외부 인터페이스를 구분 짓는 것` 이다.

### 내부 인터페이스와 외부 인터페이스

- 내부 인터페이스(internal interface) – 동일한 클래스 내의 다른 메서드에선 접근할 수 있지만, 클래스 밖에선 접근할 수 없는 프로퍼티와 메서드
- 외부 인터페이스(external interface) – 클래스 밖에서도 접근 가능한 프로퍼티와 메서드
- public: 어디서든지 접근할 수 있으며 외부 인터페이스를 구성한다.
- private: 클래스 내부에서만 접근할 수 있으며 내부 인터페이스를 구성할 때 쓰인다.

### 프로퍼티 보호하기

```jsx
class CoffeeMachine {
  waterAmount = 0; // 물통에 차 있는 물의 양

  constructor(power) {
    this.power = power;
    alert( `전력량이 ${power}인 커피머신을 만듭니다.` );
  }

}

// 커피 머신 생성
let coffeeMachine = new CoffeeMachine(100);

// 물 추가
coffeeMachine.waterAmount = 200;

// 변경 후
class CoffeeMachine {
  _waterAmount = 0;

  set waterAmount(value) {
    if (value < 0) throw new Error("물의 양은 음수가 될 수 없습니다.");
    this._waterAmount = value;
  }

  get waterAmount() {
    return this._waterAmount;
  }

  constructor(power) {
    this._power = power;
  }
}
```

프로퍼티 waterAmount와 power는 public이다. 손쉽게 waterAmount와 power를 읽고 원하는 값으로 변경하기 쉬운 상태이다. 

**protected 프로퍼티 명 앞엔 밑줄 `_`이 붙는다.**

### 읽기 전용 프로퍼티

프로퍼티를 사용할 때 읽기만 가능하도록 만들어야 한다. 그럴 때는 setter는 만들지 않고 getter를 통해 값만 읽도록 할 수 있다.

```jsx
class CoffeeMachine {
  // ...

  constructor(power) {
    this._power = power;
  }

  get power() {
    return this._power;
  }

}

// 커피 머신 생성
let coffeeMachine = new CoffeeMachine(100);

alert(`전력량이 ${coffeeMachine.power}인 커피머신을 만듭니다.`); // 전력량이 100인 커피머신을 만듭니다.

coffeeMachine.power = 25; // Error (setter 없음)
```

### private 프로퍼티

private 프로퍼티와 메서드는 `#`으로 시작한다. `#`이 붙으면 클래스 안에서만 접근할 수 있다.

private 필드는 클래스 외부나 자손 클래스에서 접근할 수 없다. private 필드는 public 필드와 상충하지 않는다.

# 내장 클래스 확장하기

배열, 맵 같은 내장 클래스도 확장이 가능하다.

```jsx
// 메서드 하나를 추가합니다(더 많이 추가하는 것도 가능).
class PowerArray extends Array {
  isEmpty() {
    return this.length === 0;
  }
}

let arr = new PowerArray(1, 2, 5, 10, 50);
alert(arr.isEmpty()); // false

let filteredArr = arr.filter(item => item >= 10);
alert(filteredArr); // 10, 50
alert(filteredArr.isEmpty()); // false
```

## 내장 객체와 정적 메서드 상속

`Object.keys` `Array.isArray` 등의 자체 정적 메서드를 갖습니다.

네이티브 클래스들은 서로 상속 관계를 맺는다. `Array` 는 `Object` 를 상속 받는다.

내장 클래스는 정적 메서드를 상속받지 못한다.

`Array`와 `Date`는 모두 `Object`를 상속받기 때문에 두 클래스의 인스턴스에선 `Object.prototype`에 구현된 메서드를 사용할 수 있다. 그런데 `Array.[[Prototype]]`와 `Date.[[Prototype]]`은 `Object`를 참조하지 않기 때문에 `Array.keys()`나 `Date.keys()`같은 정적 메서드를 인스턴스에서 사용할 수 없다.

아래는 `Date`와 `Object`의 관계를 나타낸 그림이다.

![](https://velog.velcdn.com/images/ehgns0305/post/e5162056-9308-469d-8c19-eb44868d9e17/image.png)

# instanceof 로 클래스 확인하기

`instacneof` 연산자를 사용하면 객체가 특정 클래스에 속하는지 아닌지를 확인할 수 있다.

`instaceof` 는 상속 관계도 확인해준다.

### instanceof 연산자

```jsx
obj instanceof Class
```

`obj`가 `Class`에 속하거나 `Class`를 상속받는 클래스에 속하면 `true`가 반환된다.

`instanceof` 연산자는 보통, 프로토타입 체인을 거슬로 올라가며 인스턴스 여부나 상속 여부를 확인한다. 정적 메서드 `Symbol.hasInstance`을 사용하면 직접 확인 로직을 설정할 수도 있다.

1. 클래스에 정적 메서드 `Symbol.hasInstance`가 구현되어 있으면, `obj instanceof Class`문이 실행될 때, `Class[Symbol.hasInstance](obj)`가 호출된다. 호출 결과는 `true`나 `false`이어야 한다.
2. 그런데, 대부분의 클래스엔 `Symbol.hasInstance`가 구현되어있지 않다. 이럴 땐 일반적인 로직이 사용됩니다. `obj instanceOf Class`는 `Class.prototype`이 `obj` 프로토타입 체인 상의 프로토타입 중 하나와 일치하는지 확인한다.

# 믹스인

객체엔 단 하나의 `[[Prototype]]` 만 있을 수 있고, 클래스는 클래스 하나만 상속받을 수 있다.

믹스인 - 다른 클래스를 상속받을 필요 없이 이들 클래스에 구현되어있는 메서드를 담고 있는 클래스를 정의한다.

믹스인은 특정 행동을 실행해주는 메서드를 제공하는데 단독으로 쓰이지 않고 다른 클래스에 행동을 더해주는 용도로 사용된다.

```jsx
// 믹스인
let sayHiMixin = {
  sayHi() {
    alert(`Hello ${this.name}`);
  },
  sayBye() {
    alert(`Bye ${this.name}`);
  }
};

// 사용법:
class User {
  constructor(name) {
    this.name = name;
  }
}

// 메서드 복사
Object.assign(User.prototype, sayHiMixin);

// 이제 User가 인사를 할 수 있습니다.
new User("Dude").sayHi(); // Hello Dude!

class User extends Person {
	// ...
}

Object.assign(User.prototype, sayHiMixin)
```

```jsx
let sayMixin = {
  say(phrase) {
    alert(phrase);
  }
};

let sayHiMixin = {
  __proto__: sayMixin, // (Object.create를 사용해 프로토타입을 설정할 수도 있습니다.)

  sayHi() {
    // 부모 메서드 호출
    super.say(`Hello ${this.name}`); // (*)
  },
  sayBye() {
    super.say(`Bye ${this.name}`); // (*)
  }
};

class User {
  constructor(name) {
    this.name = name;
  }
}

// 메서드 복사
Object.assign(User.prototype, sayHiMixin);

// 이제 User가 인사를 할 수 있습니다.
new User("Dude").sayHi(); // Hello Dude!
```

![](https://velog.velcdn.com/images/ehgns0305/post/9ebb78d6-e470-400b-bc8b-74a4c14ad151/image.png)

`sayHi`와 `sayBye`가 생성된 곳이 `sayHiMixin`이기 때문입니다. 따라서 메서드를 복사했더라도, 이 메서드들의 내부 프로퍼티인 `[[HomeObject]]`는 위 그림처럼 `sayHiMixin`을 참조합니다.

메서드의 `super`가 `[[HomeObject]].[[Prototype]]`내에서 부모 메서드를 찾기 때문에, 메서드는 `User.[[Prototype]]`이 아닌 `sayHiMixin.[[Prototype]]`을 검색합니다.