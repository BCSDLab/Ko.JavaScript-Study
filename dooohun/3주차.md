# . 프로토타입 상속

## [[Prototype]]

자바스크립트의 객체는 명세서에서 명명한 `[[Prototype]]`이라는 숨김 프로퍼티를 갖는다. 이 숨김 프로퍼티 값은 `null`이거나 다른 객체에 대한 참조가 되는데, 다른 객체를 참조하는 경우 참조 대상을 '프로토타입(prototype)'이라 부른다.

Object에서 프로퍼티를 읽으려고 하는데 해당 프로퍼티가 없으면 자바스크립트는 자동으로 프로토타입에서 프로퍼티를 찾는다.

```jsx
let animal = {
	eats: true;
}
let rabbit = {
	jumps: true;
}
rabbit.__proto__ = animal;

alert(rabbit.eats); // true
alert(rabbit.jumps); // true
```

![](https://velog.velcdn.com/images/ehgns0305/post/f3d065fb-c495-4197-b18e-8c9a720a2933/image.png)

> `__proto__` 는 `[[Prototype]]` 용 getter와 setter입니다.
> 

`rabbit의 프로토타입은 animal이다.` 혹은 `rabbit은 animal을 상속받는다.` 라고 말할 수 있다.

프로토타입을 설정해 준 덕분에 rabbit에서도 animal에 구현된 유용한 프로퍼티와 메서드를 사용할 수 있게 되었다. 프로토타입에서 상속받은 프로퍼티를 `상속 프로퍼티`라고 한다.

```jsx
let animal = {
  eats: true,
  walk() {
    alert("동물이 걷습니다.");
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

let longEar = {
  earLength: 10,
  __proto__: rabbit
};

// 메서드 walk는 프로토타입 체인을 통해 상속받았습니다.
longEar.walk(); // 동물이 걷습니다.
alert(longEar.jumps); // true (rabbit에서 상속받음)
```

제약 사항

1. 순환 참조는 허용되지 않는다.
2. `__proto__`의 값은 객체나 `null` 만 가능하다. 다른 자료형은 무시된다.

## 프로토타입은 읽기 전용이다

프로토타입은 프로퍼티를 읽을 때만 사용한다. 프로퍼티를 추가, 수정하거나 지우는 연산은 객체에 직접 해야한다.

```jsx
let animal = {
  eats: true,
  walk() {
    /* rabbit은 이제 이 메서드를 사용하지 않습니다. */
  }
};

let rabbit = {
  __proto__: animal
};

rabbit.walk = function() {
  alert("토끼가 깡충깡충 뜁니다.");
};

rabbit.walk(); // 토끼가 깡충깡충 뜁니다.
```

`rabbit.walk()` 를 호출하면 프로토타입에 있는 메서드가 실행되지 않고, 객체 `rabbit` 에 직접 추가한 메서드가 실행된다.

접근자 프로퍼티는 setter 함수를 사용해 프로퍼티에 값을 할당하므로 접근자 프로퍼티에 값을 할당하면 객체에 프로퍼티가 추가되는게 아니라 setter 함수가 호출되면서 조금 다르게 동작한다.

```jsx
let user = {
  name: "John",
  surname: "Smith",

  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  },

  get fullName() {
    return `${this.name} ${this.surname}`;
  }
};

let admin = {
  __proto__: user,
  isAdmin: true
};

alert(admin.fullName); // John Smith (*)

// setter 함수가 실행됩니다!
admin.fullName = "Alice Cooper"; // (**)

alert(admin.fullName); // Alice Cooper, setter에 의해 추가된 admin의 프로퍼티(name, surname)에서 값을 가져옴
alert(user.fullName); // John Smith, 본래 user에 있었던 프로퍼티 값
```

## this가 나타내는 것

`this` 는 프로토타입에 영향을 받지 않는다.

**메서드를 객체에서 호출했든 프로토타입에서 호출했든 상관없이 `this`는 언제나 `.` 앞에 있는 객체이다.**

```jsx
let animal = {
  walk() {
    if (!this.isSleeping) {
      alert(`동물이 걸어갑니다.`);
    }
  },
  sleep() {
    this.isSleeping = true;
  }
};

let rabbit = {
  name: "하얀 토끼",
  __proto__: animal
};

// rabbit에 새로운 프로퍼티 isSleeping을 추가하고 그 값을 true로 변경합니다.
rabbit.sleep();

alert(rabbit.isSleeping); // true
alert(animal.isSleeping); // undefined (프로토타입에는 isSleeping이라는 프로퍼티가 없습니다.)
```

## for…in 반복문

`for...in` 은 상속 프로퍼티도 순회대상에 포함시킨다.

```jsx
let animal = {
  eats: true
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

// Object.keys는 객체 자신의 키만 반환합니다.
alert(Object.keys(rabbit)); // jumps

// for..in은 객체 자신의 키와 상속 프로퍼티의 키 모두를 순회합니다.
for(let prop in rabbit) alert(prop); // jumps, eats
```

# 2. 함수의 prototype 프로퍼티

생성자 함수를 사용해 객체를 만든 경우 프로토타입이 어떻게 동작하는지 알아보자. 생성자 함수로 객체를 만들었을 때 리터럴 방식과 다른점은 생성자 함수의 프로토타입이 객체인 경우에 `new` 연산자를 사용해 만든 객체는 생성자 함수의 프로토타입 정보를 사용해 [[Prototype]]을 설정한다는 것이다.

```jsx
let animal = {
  eats: true
};

function Rabbit(name) {
  this.name = name;
}

Rabbit.prototype = animal;

let rabbit = new Rabbit("흰 토끼"); //  rabbit.__proto__ == animal

alert( rabbit.eats ); // true
```

`Rabbit.prototype = animal`은 "`new Rabbit`을 호출해 만든 새로운 객체의 `[[Prototype]]`을 `animal`로 설정하라."는 것을 의미한다.

<aside>
🤔 F.prototype은 new F를 호출할 때만 사용된다.

</aside>

## 함수의 디폴트 프로퍼티 prototype과 constructor 프로퍼티

개발자가 특별히 할당하지 않더라도 모든 함수는 기본적으로 `prototype` 프로퍼티를 갖는다.

디폴트 프로퍼티 prototype은 constructor 프로퍼티 하나만 있는 객체를 가리키는데, 여기서 `constructor` 프로퍼티는 함수 자신을 가리킨다.

```jsx
function Rabbit() {}
// 함수를 만들기만 해도 디폴트 프로퍼티인 prototype이 설정됩니다.
// Rabbit.prototype = { constructor: Rabbit }

alert( Rabbit.prototype.constructor == Rabbit ); // true
```

**자바스크립트는 알맞은 `"constructor"` 값을 보장하지 않는다**는 점입니다.

함수엔 기본으로 `"prototype"`이 설정된다라는 사실 그게 전부입니다. `"constructor"`와 관련해서 벌어지는 모든 일은 전적으로 개발자에게 달려있습니다.

# 3. 내장 객체의 프로토타입

## Object.prototype

```jsx
let obj = {};

alert(obj.__proto__ === Object.prototype); // true

alert(obj.toString === obj.__proto__.toString); //true
alert(obj.toString === Object.prototype.toString); //true
```

![](https://velog.velcdn.com/images/ehgns0305/post/32d92455-5b3e-47a8-9065-c36ddc9dc41e/image.png)

![](https://velog.velcdn.com/images/ehgns0305/post/ac2c0be3-d524-4a82-a166-e6d8af90c0fd/image.png)

`new Object()`를 호출하거나 리터럴 문법 `{...}`을 사용해 객체를 만들 때, 새롭게 생성된 객체의 `[[Prototype]]`은 바로 앞 챕터에서 언급한 규칙에 따라 `Object.prototype`을 참조합니다.

따라서 `obj.toString()`을 호출하면 `Object.prototype`에서 해당 메서드를 가져오게 됩니다.

## 다양한 내장 객체의 프로토타입

`Array`, `Date`, `Function`을 비롯한 내장 객체들 역시 프로토타입에 메서드를 저장해 놓습니다.

배열 `[1, 2, 3]`을 만들면 `new Array()`의 디폴트 생성자가 내부에서 동작하여 `Array.prototype`이 배열 `[1, 2, 3]`의 프로토타입이 되고 개발자는 `Array.prototype`을 통해 배열 메서드를 사용할 수 있습니다. 이런 내부 동작은 메모리 효율을 높여주는 장점을 가져다줍니다.

명세서에선 모든 내장 프로토타입의 상속 트리 꼭대기엔 `Object.prototype`이 있어야 한다고 규정합니다. 이런 명세 때문에 몇몇 사람들은 "모든 것은 객체를 상속받는다."라는 말을 하기도 합니다.

![](https://velog.velcdn.com/images/ehgns0305/post/04c9f375-5f4f-440c-83fd-d5d7254e21ad/image.png)

## 원시값

문자열과 숫자, 불린값은 객체가 아니다. 그런데 이런 원시 타입 값의 프로퍼티에 접근하려고 하면 내장 생성자 `String` `Number` `Boolean` 을 사용하는 임시 래퍼 객체가 생성된다. 임시 래퍼 객체는 ㅣㅇ런 메서드를 제공한고 난 후 사라진다. `String.prototype`, `Number.prototype`, `Boolean.prototype`을 사용해 쓰도록 규정합니다.

> **`null`과 `undefined`에 대응하는 래퍼 객체는 없습니다.**
> 
> 
> 특수 값인 `null`과 `undefined`는 문자열과 숫자, 불린값과는 거리가 있습니다. `null`과 `undefined`에 대응하는 래퍼 객체는 없습니다. 따라서 `null`과 `undefined`에선 메서드와 프로퍼티를 이용할 수 없습니다. 프로토타입도 물론 사용할 수 없습니다.
> 

## 네이티브 프로토타입 변경하기

네이티브 프로토타입은 수정할 수 있습니다. `String.prototype`에 메서드를 하나 추가하면 모든 문자열에서 해당 메서드를 사용할 수 있습니다.

`String.prototype.show = function() {alert(this);};"BOOM!".show(); // BOOM!`

개발을 하다 보면 새로운 내장 메서드를 만들면 좋지 않을까 하는 생각이 들 때가 있습니다. 그런데 이는 좋지 않은 방법입니다.

**모던 프로그래밍에서 네이티브 프로토타입 변경을 허용하는 경우는 딱 하나뿐입니다. 바로 폴리필을 만들 때입니다.**

# 4. 프로토타입 메서드와 __proto__가 없는 객체

- Object.create(proto, [descriptors])
- Object.getPrototypeOf(obj)
- Object.setPrototypeOf(obj, proto)

`__proto__` 대신 메서드를 사용하는 게 좋다.

```jsx
let animal = {
  eats: true
};

// 프로토타입이 animal인 새로운 객체를 생성합니다.
let rabbit = Object.create(animal);

alert(rabbit.eats); // true

alert(Object.getPrototypeOf(rabbit) === animal); // true

Object.setPrototypeOf(rabbit, {}); // rabbit의 프로토타입을 {}으로 바꿉니다.
```

`__proto__`는 `[[Prototype]]`의 `getter`, `setter`라는 점과 `__proto__`는 다른 메서드처럼 `Object.prototype`에 정의되어 있다는 것을 잘 인지해야한다.

간단한 메서드도 같이 살펴보면 좋다.

- Object.keys(obj) / Object.values(obj) / Object.entries(obj) – `obj` 내 열거 가능한 프로퍼티 키, 값, 키-값 쌍을 담은 배열을 반환합니다.
- Object.getOwnPropertySymbols(obj) – `obj` 내 심볼형 키를 담은 배열을 반환합니다.
- Object.getOwnPropertyNames(obj) – `obj` 내 문자형 키를 담은 배열을 반환합니다.
- Reflect.ownKeys(obj) – `obj` 내 키 전체를 담은 배열을 반환합니다.
- obj.hasOwnProperty(key) – 상속받지 않고 `obj` 자체에 구현된 키 중 이름이 `key`인 것이 있으면 `true`를 반환합니다.

# 자바스크립트는 왜 프로토타입을 선택했는가?

## 플라톤과 이데아, 그리고 클래스 기반 객체지향 프로그래밍

- 영혼 / 육체
- 추상적 / 구체적
- 이데아 / 프랙티스

눈앞에 실제로, 구체적으로 존재하는 사물이 있다면 반드시 그것의 본질이 존재한다. ⇒ 플라톤의 주장

본질 세계를 이데아라고 하고 현실의 의자는 모두 이데아의 ‘의자’를 모방한 의자라는 것이다.

<aside>
🤔 영어권 사고방식은 무엇이 다를까?
영어적 사고방식에는 위에서 설명한 `이분법적 세계관` 이 기본이다. 한국어와 영어를 볼 때 다른점을 보면 `관사` 가 특별하다는 것을 알 수 있다. a, the, -es(s), 관사를 붙이지 않은 명사 이 것들의 차이가 너무나 어려웠는데 `이분법적 세계관` 을 투영하여 보면 조금 이해가 될 수 있다.

- chair: 이데아에 존재하는 본질적인, 추상적인 의자. ⇒ 현실 세계에 존재하지 않는다.
- a chair, the chair, chairs: 현실 세계에 존재하는 의자

</aside>

### 분류(Classification)

플라톤의 이데아 이론은 그의 제자 아리스토텔레스에 의해서 분류(Classification)란 개념으로 정립된다.

- `개체의 속성이 동일한 경우` 개체 그룹이 같은 범주에 속한다. 범주는 정의와 구별의 합이다.

속성은 클래스의 프로퍼티를 의미한다.

### 프로퍼티와 메서드

**객체는 프로퍼티의 집합이다.**

```jsx
const person = {
	name: "Dohun",
	age: 24
}
```

- 프로퍼티: `name: “Dohun”`, `age: 24`

자바스크립트에서 method는 함수로 된 property이다.

- property: 속성
- method: 행동

```jsx
const listA = [];

// 프로퍼티
listA.length

// 메소드
listA.push(1);
```

## 자바스크립트 프로토타입과 클래스

프로토타입이란 개념이 이 분류(Classification) 이론을 정면으로 반박하여 나온 이론이다.

> 공유 속성의 관점에서 정의하기 어려운 개념이 있다. 사실상 올바른 **분류**란 없다.
세계에 미리 내재되어서 대상과 언어를 완전히 규정하는 어떤 언어란 존재하지 않는다.
표현은 삶의 흐름 속에서만 의미를 갖는다.

### 의미사용이론 (the use theory of meaning)

사용에 의해 의미가 결정된다는 이론이다. 단어의 쓰임새가 곧 의미가 된다. 즉 단어의 `진정한 본래의 의미` 란 존재하지 않고 `상황과 맥락에 의해서 결정된다` 라고 주장한다. 플라톤의 이데아와 아리스토텔레스의 분류 개념을 완전히 반박하고 있습니다.

비트겐슈타인은 벽돌을 통해 설명했다. 누군가 `벽돌!` 이라고 외쳤을 때 상황마다 그 의미는 달라진다.

- (벽돌이 필요할 때): 벽돌을 달라
- (벽돌로 보수해야 할 때): 벽돌을 채우라
- (벽돌이 떨어질 때): 벽돌을 피해라

맥락(Context)이 중요하다는 것을 알 수 있고, 이를 통해 컨텍스트로 프로토타입 기반 언어의 실행 컨텍스트를 설명할 수 있다.

### 가족 유사성 (Family Resemblance)

인간이 현실에서 실제로 대상을 분류할 때 속성이 아닌 `가족 유사성`을 통해 분류하게 된다고 한다.

![](https://velog.velcdn.com/images/ehgns0305/post/c5681c87-e640-4669-9f58-0ae807432ff4/image.png)

모두 공유하는 공통의 속성은 없지만, 각각의 유사성(갈색 머리, 안경, 수염, 큰 코)이 존재하는 것을 알 수 있고 이를 통해 가족으로 분류한다. 이런 분류 방식을 `가족 유사성` 에 의한 분류라고 한다.

### Rosch의 프로타타입 이론

Rosch는 한 가지 실험을 합니다.

- 실험 참가자들에게 여러 범주 구성원(사과, 코코넛, 오렌지)의 속성을 적어보라고 함
- 각 범주 구성원에 대해 범주의 다른 구성원과 공유하는 속성의 개수를 도출함
- 사과, 오렌지 : 2점(둥글다. 즙이 있다.)
- 코코넛 : 1점(둥글다)

점수가 높을수록 가족 유사성이 높다고 볼 수 있습니다. 프로토타입 이론에서는 사과와 오렌지가 가장 전형적인 무엇인가로 볼 수 있지만, 프로토타입 이론에서는 사과와 오렌지가 가장 전형적인 무언가로 볼 수 있다.

이 실험을 통해 `인간은 등급이 매겨진 구조를 가진다` 라고 주장한다. 인간은 사물을 분류할 때 자연스럽게 가장 유사성이 높은 것 순서대로 등급을 매긴다는 의미로 볼 수 있다. 이렇게 분류했을 때 가장 높은 등급을 가진 녀석이 나오는데 그것이 바로 원형(Prototype)이다.

![](https://velog.velcdn.com/images/ehgns0305/post/72a5371b-d470-479c-8cfd-2b5019ab015a/image.png)

즉 객체는 `정의` 로부터 분류되는 것이 아니라 가장 좋은 `보기` (prototype, exemplar)로 부터 범주화된다고 한다.

이러한 분류 체계는 매우 경제적이다. 새로운 대상을 접해서 분류해야 할 때 몇 가지 특징만 원형(prototype)과 비교 확인만 하면 된다.

이 이론에서 또 한가지 중요한 것은 같은 단어라도 누가 어떤 상황(context)에서 접했나에 따라 의미가 달라진다는 것이다. (의미사용이론)

- 일반인의 생각 - 참새는 명확하게 `새` 이지만, 펭귄은 해당 범주에 포함되지 않는다.
- 조류학자의 생각 - 참새와 펭귄은 명확하게 유사한 새의 범주에 속할 수 있다.

같은 단어여도 어떤 상황(누가, 어디서 등등)에서 접했나에 따라 범주가 크게 달라진다.

### 프로토타입 기반 객체지향 프로그래밍

프로토타입 기반 OOP 언어의 특징

- 개별 객체(instance) 수준에서 메소드와 변수를 추가
- 객체 생성은 일반적으로 복사를 통해 이루어짐
- 확장(extends)은 클래스가 아니라 위임(delegation)
- 개별 객체 수준에서 객체를 수정하고 발전시키는 능력은 **선험적 분류의 필요성을 줄이고 반복적인 프로그래밍 및 디자인 스타일**을 장려
- 프로토타입 프로그래밍은 일반적으로 `분류하지 않고 유사성을 활용하도록 선택`
- 결과적으로 설계는 맥락에 의해 평가

다시 정리해보면

- 프로토타입 언어에서는 `분류`를 우선하지 않는다. 생성된 객체 위주로 유사성을 정의한다.
- 어휘, 쓰임새는 `맥락`(context)에 의해 평가된다.
    - 실행 컨텍스트, 스코프 체인이 여기서 파생되었다.
    - 클로져, this, 호이스팅 등등. 이 모든 것이 프로토타입의 ‘맥락’을 표현하기 위한 것이다.