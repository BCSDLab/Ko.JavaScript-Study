# 1. 재귀와 스택

## 실행 컨텍스트와 스택

- 실행 컨텍스트란?

함수 실행에 대한 세부 정보를 담고 있는 내부 데이터 구조이다. 제어 흐름의 현재 위치, 변수의 현재 값, `this` 의 값 등 상세 내부 정보가 실행 컨텍스트에 저장된다.

함수 호출 `일` 회당 정확히 하나의 실행 컨텍스트가 생성된다.

함수 내부에 중첩 호출이 있을 때는 아래와 같은 절차가 수행됩니다.

- 현재 함수의 실행이 일시 중지된다.
- 중지된 함수와 연관된 실행 컨텍스트는 **실행 컨텍스트 스택**이라는 특별한 자료 구조에 저장된다.
- 중첩 호출이 실행된다.
- 중첩 호출 실행이 끝난 이후 실행 컨텍스트 스택에서 일시 중단한 함수의 실행 컨텍스트를 꺼내오고, 중단한 함수의 실행을 다시 이어나간다.

[예시 - pow(2,3)](https://ko.javascript.info/recursion#ref-109)를 통해 쉽게 이해할 수 있다.

## 재귀적 순회

재귀는 **재귀적 순회**를 구현할 때 사용하면 좋다.

```jsx
let company = {
  sales: [{
    name: 'John',
    salary: 1000
  }, {
    name: 'Alice',
    salary: 1600
  }],

  development: {
    sites: [{
      name: 'Peter',
      salary: 2000
    }, {
      name: 'Alex',
      salary: 1800
    }],

    internals: [{
      name: 'Jack',
      salary: 1300
    }]
  }
};
```

모든 임직원의 급여를 더한 값을 구해야 한다고하면 어떻게 할 수 있을까?

- `for` 반복문을 만들고 한 단계 아래의 부서에 중첩 반복문을 돌리자
- 재귀를 통해 해결하자
    1. 임직원 *배열* 을 가진 ‘단순한’ 부서 – 간단한 반복문으로 급여 합계를 구할 수 있다.
    2. `N`개의 하위 부서가 있는 객체 – 각 하위 부서에 속한 임직원의 급여 합계를 얻기 위해 `N`번의 재귀 호출을 하고, 최종적으로 모든 하위부서 임직원의 급여를 더한다.

```jsx
// 급여 합계를 구해주는 함수
function sumSalaries(department) {
  if (Array.isArray(department)) { // 첫 번째 경우
    return department.reduce((prev, current) => prev + current.salary, 0); // 배열의 요소를 합함
  } else { // 두 번째 경우
    let sum = 0;
    for (let subdep of Object.values(department)) {
      sum += sumSalaries(subdep); // 재귀 호출로 각 하위 부서 임직원의 급여 총합을 구함
    }
    return sum;
  }
}
```

반복문을 사용하면 객체의 깊이가 깊어지면 반복문의 중첩 횟수를 늘려야 하지만, 재귀는 그렇지 않다.

# 2. 나머지 매개변수와 전개 구문

## 나머지 매개변수 `...`

여분의 매개변수는 그 값들을 담은 배열 이름을 마침표 세 개 `...` 뒤에 붙여주면 함수 선언부에 포함시킬 수 있다. ⇒ “남아 있는 매개변수들을 한데 모아 배열에 접어넣어라”라는 의미를 갖고 있다.

```jsx
function sumAll(...args) { // args는 배열의 이름입니다.
  let sum = 0;

  for (let arg of args) sum += arg;

  return sum;
}

alert( sumAll(1) ); // 1
alert( sumAll(1, 2) ); // 3
alert( sumAll(1, 2, 3) ); // 6
```

> ⚠️ **나머지 매개변수는 항상 마지막에 있어야 한다.**
> 

## arguments 객체

유사 배열 객체인 `arugments` 를 사용하면 인덱스를 사용해 인수에 접근할 수 있다.

```jsx
function showName() {
  alert( arguments.length );
  alert( arguments[0] );
  alert( arguments[1] );

  // arguments는 이터러블 객체이기 때문에
  // for(let arg of arguments) alert(arg); 를 사용해 인수를 펼칠 수 있습니다.
}

// 2, Bora, Lee가 출력됨
showName("Bora", "Lee");

// 1, Bora, undefined가 출력됨(두 번째 인수는 없음)
showName("Bora");
```

`arguments` 는 유사 배열 객체이면서 이터러블 객체이다. 따라서 배열 메서드를 사용할 수 없다는 단점이 있다.

> ⚠️ **화살표 함수는 `arguments` 객체를 지원하지 않는다.**
> 

## 스프레드 문법

배열을 통째로 매개변수에 넘겨주는 기능이 필요할 때가 있다.

`Math.max (arr[0], arr[1], arr[2])` 처럼 배열 요소를 수동으로 나열하는것은 불편하기 때문에 **spread syntax**를 사용하면 쉽게 사용할 수 있다. `...` 를 사용하여 이터러블 객체의 인수 목록으로 확장된다.

```jsx
let arr = [1,3,5];
let str = "Hello";

alert( Math.max(...arr)); // 9
alert( [...str]) /// H,e,l,l,o
```

- `Array.from` 은 유사 배열 객체와 이터러블 객체 둘 다 사용할 수 있습니다.
- 스프레드 문법은 이터러블 객체에만 사용할 수 있습니다.

## 배열과 객체의 복사본 만들기

`Object.assign()` 말고도 스프레드 문법을 사용하면 배열과 객체를 복사할 수 있습니다.

```jsx
let arr = [1, 2, 3];
let arrCopy = [...arr]; // 배열을 펼쳐서 각 요소를 분리후, 매개변수 목록으로 만든 다음에
                        // 매개변수 목록을 새로운 배열에 할당함

// 배열 복사본의 요소가 기존 배열 요소와 진짜 같을까요?
alert(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true

// 두 배열은 같을까요?
alert(arr === arrCopy); // false (참조가 다름)

// 참조가 다르므로 기존 배열을 수정해도 복사본은 영향을 받지 않습니다.
arr.push(4);
alert(arr); // 1, 2, 3, 4
alert(arrCopy); // 1, 2, 3
```

```jsx
let obj = { a: 1, b: 2, c: 3 };
let objCopy = { ...obj }; // 객체를 펼쳐서 각 요소를 분리후, 매개변수 목록으로 만든 다음에
                          // 매개변수 목록을 새로운 객체에 할당함

// 객체 복사본의 프로퍼티들이 기존 객체의 프로퍼티들과 진짜 같을까요?
alert(JSON.stringify(obj) === JSON.stringify(objCopy)); // true

// 두 객체는 같을까요?
alert(obj === objCopy); // false (참조가 다름)

// 참조가 다르므로 기존 객체를 수정해도 복사본은 영향을 받지 않습니다.
obj.d = 4;
alert(JSON.stringify(obj)); // {"a":1,"b":2,"c":3,"d":4}
alert(JSON.stringify(objCopy)); // {"a":1,"b":2,"c":3}
```

# 3. 변수의 유효범위와 클로저

## 코드 블록

코드 블록 `{...}` 안에서 선언한 변수는 블록 안에서만 사용할 수 있다.

`if`, `for`, `while` 등에서도 마찬가지로 `{...}` 안에서 선언한 변수는 오직 블록 안에서만 접근 가능하다.

### 중첩 함수

함수 내부에서 선언한 함수는 ‘중첩(nested)’ 함수라고 부른다.

```jsx
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();

alert( counter() ); // 0
alert( counter() ); // 1
alert( counter() ); // 2
```

의문점

- `counter`를 여러 개 만들었을 때, 이 함수들은 서로 독립적일까?
- 함수와 중첩 함수 내 `count` 변수엔 어떤 값이 할당될까?

## 렉시컬 환경

### 1. 변수

자바스크립트에선 실행 중인 함수, 코드 블록 `{...}`, 스크립트 전체는 **렉시컬 환경(Lexical Environment)** 이라 불리는 내부 숨김 연관 객체(internal hidden associated object)를 갖습니다.

렉시컬 환경 객체는 두 부분으로 구성된다.

1. 환경 레코드(Environment Record) – 모든 지역 변수를 프로퍼티로 저장하고 있는 객체입니다. `this` 값과 같은 기타 정보도 여기에 저장된다.
2. 외부 렉시컬 환경(Outer Lexical Environment) 에 대한 참조 – 외부 코드와 연관됨

### 2. 함수 선언문

함수 선언문으로 선언한 함수는 일반 변수와는 달리 **바로 초기화된다는 점**에서 차이가 있다.

함수 선언문으로 선언한 함수는 렉시컬 환경이 만들어지는 즉시 사용할 수 있다. 변수는 `let` 을 만나 선언이 될 때까지 사용할 수 없다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/55ebe5bb-df2f-4ad3-8902-add33e403d37/c88aaa6c-0907-4314-aa88-377302b4131f/Untitled.png)

### 3. 내부와 외부 렉시컬 환경

함수 호출 중엔 호출 중인 함수를 위한 `내부 렉시컬 환경` 과 내부 렉시컬 환경이 가리키는 `외부 렉시컬 환경` 총 2개의 렉시컬 환경을 갖게 된다.

- 내부 렉시컬 환경: `say` 내부 렉시컬 환경엔 함수의 인자인 `name`으로부터 유래한 프로퍼티 하나만 있다. `say("John")`을 호출했기 때문에, `name`의 값은 `"John"`이 된다.
- 외부 렉시컬 환경: 전역 렉시컬 환경이다. 전역 렉시컬 환경은 `phrase`와 함수 `say`를 프로퍼티로 갖는다.

**코드에서 변수에 접근할 땐, 먼저 내부 렉시컬 환경을 검색 범위로 잡는다. 내부 렉시컬 환경에서 원하는 변수를 찾지 못하면 검색 범위를 내부 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 확장한다. 이 과정은 검색 범위가 전역 렉시컬 환경으로 확장될 때까지 반복된다.**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/55ebe5bb-df2f-4ad3-8902-add33e403d37/4db166aa-15e5-4cd2-93cd-ec750696a4b6/Untitled.png)

### 4. 함수를 반환하는 함수

```jsx
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/55ebe5bb-df2f-4ad3-8902-add33e403d37/b8e2f932-f6c3-4880-91e5-b1a76194e870/Untitled.png)

`makeCounter()`가 실행되는 도중엔 본문(`return count++`)이 한줄 짜리인 중첩 함수가 만들어집니다. 현재는 중첩함수가 생성되기만 하고 실행은 되지 않은 상태입니다.

모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억한다. 함수는 `[[Environment]]`라 불리는 숨김 프로퍼티를 갖는데, 여기에 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장된다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/55ebe5bb-df2f-4ad3-8902-add33e403d37/7737ae22-8988-4b93-ab86-7664a40ba9c3/Untitled.png)

따라서 `counter.[[Environment]]`엔 `{count: 0}`이 있는 렉시컬 환경에 대한 참조가 저장된다. 호출 장소와 상관없이 함수가 자신이 태어난 곳을 기억할 수 있는 건 바로 이 `[[Environment]]` 프로퍼티 덕분이다. `[[Environment]]`는 함수가 생성될 때 딱 한 번 값이 세팅되고 영원히 변하지 않는다.

`counter()`를 호출하면 각 호출마다 새로운 렉시컬 환경이 생성됩니다. 그리고 이 렉시컬 환경은 `counter.[[Environment]]`에 저장된 렉시컬 환경을 외부 렉시컬 환경으로서 참조한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/55ebe5bb-df2f-4ad3-8902-add33e403d37/5692da69-c829-4111-a151-5e0ad20f2b2e/Untitled.png)

실행 흐름이 중첩 함수의 본문으로 넘어오면 `count` 변수가 필요한데, 먼저 자체 렉시컬 환경에서 변수를 찾는다. 익명 중첩 함수엔 지역변수가 없기 때문에 이 렉시컬 환경은 비어있는 상황이다(`<empty>`). 이제 `counter()`의 렉시컬 환경이 참조하는 외부 렉시컬 환경에서 `count`를 찾아본다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/55ebe5bb-df2f-4ad3-8902-add33e403d37/1071e673-d5be-429e-af02-6cd5314273f6/Untitled.png)

이제 `count++`가 실행되면서 count 값이 1 증가해야하는데, **변숫값 갱신은 변수가 저장된 렉시컬 환경에서 이뤄진다.**

> ⚠️ **클로저**
[클로저](https://en.wikipedia.org/wiki/Closure_(computer_programming))는 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미합니다. 몇몇 언어에선 클로저를 구현하는 게 불가능하거나 특수한 방식으로 함수를 작성해야 클로저를 만들 수 있습니다. 하지만 자바스크립트에선 모든 함수가 자연스럽게 클로저가 됩니다.
> 

## 가비지 컬렉션

함수 호출이 끝나면 함수에 대응하는 렉시컬 환경이 메모리에서 제거된다. 함수와 관련된 변수들은 이때 모두 사라진다. 함수 호출이 끝나면 관련 변수를 참조할 수 없는 이유가 바로 여기에 있다. 자바스크립트에서 모든 객체는 **도달 가능한 상태**일때만 메모리에 유지됩니다.

```jsx
function f() {
  let value = 123;

  return function() {
    alert(value);
  }
}

let g = f(); // g.[[Environment]]에 f() 호출 시 만들어지는
// 렉시컬 환경 정보가 저장됩니다.
```

```jsx
function f() {
  let value = Math.random();

  return function() { alert(value); };
}

// 배열 안의 세 함수는 각각 f()를 호출할 때 생성된
// 렉시컬 환경과 연관 관계를 맺습니다.
let arr = [f(), f(), f()];

let g = f();

g = null; // 도달할 수 없는 상태가 되었으므로 메모리에서 삭제됩니다.
```